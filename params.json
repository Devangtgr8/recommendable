{"body":"# Recommendable\r\n\r\nRecommendable is an engine for Rails 3 applications to quickly add the ability\r\nfor your users to Like/Dislike items and receive recommendations for new items.\r\nIt uses Redis to store your recommendations and keep them sorted by how good the\r\nrecommendation is.\r\n\r\n## Requirements\r\n\r\n* Ruby 1.9.x\r\n* Rails 3.x or 4.x\r\n* Sidekiq or Resque (or DelayedJob)\r\n\r\nBundling one of the queueing systems above is highly recommended to avoid having to manually refresh users' recommendations. If running on Rails 4, the built-in queueing system is supported. If you bundle [Sidekiq][sidekiq], [Resque][resque], or [DelayedJob][delayed_job], Recommendable will use your bundled queueing system instead. If bundling Resque, you should also include ['resque-loner'][resque-loner] in your Gemfile to ensure your users only get queued once (Sidekiq does this by default, and there is no current way to avoid duplicate jobs in DelayedJob).\r\n\r\n## Installation\r\n\r\nAdd the following to your Rails application's `Gemfile`:\r\n\r\n``` ruby\r\n  gem 'recommendable'\r\n```\r\n\r\nAfter bundling, run the installation generator:\r\n\r\n``` bash\r\n$ rails g recommendable:install\r\n```\r\n\r\nDouble check `config/initializers/recommendable.rb` for options on configuring your Redis connection. After a user likes or dislikes something new, they are placed in a queue to have their recommendations updated. If you're using the basic Rails 4.0 queue, you don't need to do anything explicit. If using Sidekiq, Resque, or DelayedJob, start your workers from the command line:\r\n\r\n``` bash\r\n# sidekiq\r\n$ bundle exec sidekiq -q recommendable\r\n# resque\r\n$ QUEUE=recommendable rake environment resque:work\r\n# delayed_job\r\n$ rake jobs:work\r\n```\r\n\r\nYou can run this command multiple times if you wish to start more than one\r\nworker. For more options on this task, head over to [defunkt/resque][resque].\r\n\r\n## Usage\r\n\r\nIn your Rails model that will be receiving recommendations:\r\n\r\n``` ruby\r\nclass User < ActiveRecord::Base\r\n  recommends :movies, :shows, :other_things\r\n  \r\n  # ...\r\nend\r\n```\r\n\r\nNote that you can only do this in one model at this time.\r\n\r\n### Liking and disliking\r\n\r\nYour users should now be able to `like` and `dislike` your recommendable objects:\r\n\r\n``` ruby\r\n>> current_user.like Movie.where(:name => \"2001: A Space Odyssey\")\r\n=> true\r\n>> current_user.like Show.where(:name => \"Arrested Development\")\r\n=> true\r\n>> current_user.dislike Movie.where(:name => \"2012\")\r\n=> true\r\n>> current_user.liked\r\n=> [#<Movie name: \"2001: A Space Odyssey\">, #<Show name: \"Arrested Development\">]\r\n>> current_user.liked_shows\r\n=> [#<Show name: \"Arrested Development\">]\r\n>> current_user.disliked_movies # or current_user.disliked\r\n=> [#<Movie name: \"2012\">]\r\n```\r\n\r\n### Ignoring and saving for later\r\n\r\nYou may wish to allow your users to allow to ignore items or recommendations, or\r\nto maintain a list of items that they know they wish to try later.\r\n\r\n``` ruby\r\n>> current_user.stash Movie.where(:name => \"Indie Game: The Movie\")\r\n=> true\r\n>> current_user.ignore Show.where(:name => \"Jersey Shore\")\r\n=> true\r\n>> current_user.stashed_movies # or current_user.stashed\r\n=> [#<Movie name: \"Indie Game: The Movie\">]\r\n>> current_user.ignored_shows # or current_user.ignored\r\n=> [#<Show name: \"Jersey Shore\">]\r\n```\r\n\r\n### Made a mistake?\r\n\r\nEach of the actions above has an opposite \"un\" action to remove items from a list:\r\n\r\n``` ruby\r\n>> current_user.unlike Show.where(:name => \"Jersey Shore\")\r\n=> true\r\n>> current_user.undislike Movie.where(:name => \"Indie Game: The Movie\")\r\n=> true\r\n>> current_user.unstash Movie.where(:name => \"2012\")\r\n=> true\r\n>> current_user.unignore Movie.where(:name => \"2001: A Space Odyssey\")\r\n=> true\r\n```\r\n\r\n### Recommendations\r\n\r\nAnd here we arrive at the whole reason this gem exists! Assuming Redis and Sidekiq\r\nhave been running, your users should automagically begin to receive recommendations\r\nsoon after liking and disliking stuff:\r\n\r\n``` ruby\r\n>> friend.like Movie.where(:name => \"2001: A Space Odyssey\")\r\n>> friend.like Movie.where(:name => \"A Clockwork Orange\")\r\n>> friend.like Show.where(:name => \"Arrested Development\")\r\n>> current_user.like Movie.where(:name => \"2001: A Space Odyssey\")\r\n=> true\r\n>> current_user.recommendations\r\n=> [#<Movie name: \"A Clockwork Orange\">, #<Show name: \"Arrested Development\">]\r\n>> current_user.recommendations(1)\r\n=> #<Movie name: \"A Clockwork Orange\">\r\n>> current_user.recommended_movies\r\n=> [#<Movie name: \"A Clockwork Orange\">]\r\n>> current_user.recommended_shows\r\n=> [#<Show name: \"Arrested Development\">]\r\n```\r\n\r\n### The \"best\" of your Recommendable models\r\n\r\nRecommendable does some maths in the background to calculate which of your Recommended objects, based on likes and dislikes, are the best of the best. Using the `.top` query method on your Recommendable models will return the coolest stuff you have to offer sorted by awesomeness:\r\n\r\n``` ruby\r\n>> Movie.top\r\n=> #<Movie name: \"2001: A Space Odyssey\">\r\n>> Movie.top(3)\r\n=> [#<Movie name: \"2001: A Space Odyssey\">, #<Movie name: \"A Clockwork Orange\">, #<Movie name: \"The Shining\">]\r\n```\r\n\r\n### Additional helpers\r\n\r\n``` ruby\r\n>> current_user.likes? Movie.where(:name => \"2001: A Space Odyssey\")\r\n=> true\r\n>> current_user.dislikes? Show.where(:name => \"Arrested Development\")\r\n=> false\r\n>> current_user.rated? Show.where(:name => \"Jersey Shore\")\r\n=> false\r\n>> current_user.similar_raters\r\n=> [#<User username: \"frankpoole\">, #<User username: \"davidbowman\">]\r\n>> davidbowman.liked_in_common_with frankpoole\r\n=> [#<Movie name: \"2001: A Space Odyssey\">, #<Show name: \"Arrested Development\">]\r\n>> davidbowman.liked_movies_in_common_with frankpoole\r\n=> [#<Movie name: \"2001: A Space Odyssey\">]\r\n>> davidbowman.disliked_shows_in_common_with frankpoole\r\n=> [#<Show name: \"Jersey Shore\">]\r\n>> Movie.where(:name => \"2001: A Space Odyssey\").liked_by\r\n=> [#<User username: \"davidbowman\">, #<User username: \"davidbowman\">]\r\n>> Show.where(:name => \"Arrested Development\").disliked_by\r\n=> []\r\n```\r\n\r\n### Callbacks\r\n\r\nRecommendable uses [apotonick/hooks][hooks] to implement before/after callbacks for liking, disliking, and more.\r\n\r\n```ruby\r\nclass User < ActiveRecord::Base\r\n  has_one :feed\r\n\r\n  recommends :movies\r\n  after_like :update_feed\r\n    \r\n  def update_feed(movie)\r\n    feed.update \"liked #{movie.title}!\"\r\n  end\r\nend\r\n```\r\n    \r\nYou can define before/after hooks for (un)liking, (un)disliking, (un)stashing, and (un)ignoring. Each hook takes the recommendable object as an argument and can be a block or a method name.\r\n\r\n### A note on the dynamic finders\r\n\r\nAll of the dynamically defined finders return ActiveRecord::Relations. This means you can chain other ActiveRecord query methods with them!\r\n\r\n```ruby\r\ncurrent_user.liked_movies.limit(10)\r\ncurrent_user.stashed_books.where(:author => \"Cormac McCarthy\")\r\ncurrent_user.disliked_shows.joins(:cast_members).where('cast_members.name = Kim Kardashian')\r\ncurrent_user.ignored_movies.order('year DESC')\r\ncurrent_user.recommended_movies.where('year < 2010')\r\n```\r\n\r\n## Installing Redis\r\n\r\nRecommendable requires Redis to deliver recommendations. The collaborative filtering logic is based almost entirely on set math, and Redis is blazing fast for this. _NOTE: Your redis database MUST be persistent._\r\n\r\n### Mac OS X\r\n\r\nFor Mac OS X users, homebrew is by far the easiest way to install Redis. Make sure to read the caveats after installation!\r\n\r\n``` bash\r\n$ brew install redis\r\n```\r\n\r\n### Linux\r\n\r\nFor Linux users, there is a package on apt-get.\r\n\r\n``` bash\r\n$ sudo apt-get install redis-server\r\n$ redis-server\r\n```\r\n\r\nRedis will now be running on localhost:6379. After a second, you can hit `ctrl-\\` to detach and keep Redis running in the background.\r\n\r\n### Redis problems?\r\n\r\nOops, did you kill your Redis database? Not to worry. Likes, Dislikes, Ignores,\r\nand StashedItems are stored as models in your regular database. As long as these\r\nstill exist, you can regenerate the similarity values and recommendations on the\r\nfly. But try not to have to do it!\r\n\r\n``` ruby\r\nUsers.all.each do |user|\r\n  user.send :update_similarities\r\n  user.send :update_recommendations\r\nend\r\n```\r\n\r\nWhy not stars?\r\n--------------\r\nI'll let Randall Munroe of [XKCD](http://xkcd.com/) take this one for me:\r\n\r\n[![I got lost and wandered into the world's creepiest cemetery, where the headstones just had names and star ratings. Freaked me out. When I got home I tried to leave the cemetery a bad review on Yelp, but as my hand hovered over the 'one star' button I felt this distant chill ...](http://imgs.xkcd.com/comics/star_ratings.png)](http://xkcd.com/1098/)\r\n\r\nContributing to recommendable\r\n-----------------------------\r\n \r\nOnce you've made your great commits:\r\n\r\n1. [Fork][forking] recommendable\r\n2. Create a feature branch\r\n3. Write your code (and tests please)\r\n4. Push to your branch's origin\r\n5. Create a [Pull Request][pull requests] from your branch\r\n6. That's it!\r\n\r\nLinks\r\n-----\r\n* Code: `git clone git://github.com/davidcelis/recommendable.git`\r\n* Home: <http://github.com/davidcelis/recommendable>\r\n* Docs: <http://rubydoc.info/gems/recommendable/frames>\r\n* Bugs: <http://github.com/davidcelis/recommendable/issues>\r\n* Gems: <http://rubygems.org/gems/recommendable>\r\n\r\nCopyright\r\n---------\r\n\r\nCopyright Â© 2012 David Celis. See LICENSE.txt for further details.\r\n\r\n[stars]: http://davidcelis.com/blog/2012/02/01/why-i-hate-five-star-ratings/\r\n[sidekiq]: https://github.com/mperham/sidekiq\r\n[delayed_job]: https://github.com/tobi/delayed_job\r\n[resque]: https://github.com/defunkt/resque\r\n[resque-loner]: https://github.com/jayniz/resque-loner\r\n[hooks]: https://github.com/apotonick/hooks\r\n[forking]: http://help.github.com/forking/\r\n[pull requests]: http://help.github.com/pull-requests/\r\n[collaborative filtering]: http://davidcelis.com/blog/2012/02/07/collaborative-filtering-with-likes-and-dislikes/\r\n[recommendable]: http://davidcelis.github.com/recommendable/\r\n[documentation]: http://rubydoc.info/gems/recommendable/frames","name":"Recommendable","google":"","tagline":"A recommendation engine for Likes and Dislikes in Rails 3","note":"Don't delete this file! It's used internally to help with page regeneration."}